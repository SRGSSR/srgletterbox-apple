# frozen_string_literal: true

# Customise this file, documentation can be found here:
# https://github.com/fastlane/fastlane/tree/master/fastlane/docs
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md
# can also be listed using the `fastlane actions` command

# Change the syntax highlighting to Ruby
# All lines starting with a # are ignored when running `fastlane`

# This is the minimum version number required.
fastlane_version '2.96.0'

default_platform :ios

platform :ios do
  before_all do |lane|

    # For the demo, before all, check if we have a demo release description
    if lane.to_s.downcase.include? 'demo'
      what_s_new = what_s_new_for_demo
      if what_s_new.empty?
        UI.user_error!('Whoops, there is no demo release note in the WhatsNew-demo.json file for ' + tag_version)
      end
    end

    if (!lane.to_s.downcase.include? 'dsym')
      ensure_git_status_clean
      Dir.chdir('..') { sh 'make bootstrap' }
    end
  end

  desc 'Run library tests'
  lane :tests do
    clean_result_files

    override_test_product_names

    run_tests_with_devices(['iPhone 11', 'Apple TV'])

    trainer(
      path: './fastlane',
      output_directory: './fastlane'
    )
  end

  desc "Build a new iOS nightly demo on App Center"
  lane :iOSnightly do
    build_platform = "iOS"

    appcenter_build_number = latest_appcenter_build_number(ENV['LETTERBOX_DEMO_IOS_NIGHTLY_APPCENTER_SECRET'])

    nightly(
      platform: build_platform,
      current_build_number: appcenter_build_number
    )

    changelog = default_changelog_for_nightlies(build_platform)

    appcenter_lane(
      appname: ENV['LETTERBOX_DEMO_IOS_NIGHTLY_APPCENTER_APPNAME'],
      destinations: ENV['LETTERBOX_DEMO_IOS_NIGHTLY_APPCENTER_DESTINATIONS'],
      notes: changelog,
    )

    clean_build_artifacts

    save_last_nightlies_success_git_commit_hash(build_platform)
  end

  desc "Build a new tvOS nightly demo on AppStore Connect and wait build processing. Optional 'skip_waiting_for_build_processing' parameter."
  lane :tvOSnightly do |options|
    skip_waiting_for_build_processing = options[:skip_waiting_for_build_processing] ? options[:skip_waiting_for_build_processing] : false

    update_to_appstore_app_identifier

    build_platform = "tvOS"
    appstore_platform =  "appletvos"

    appstore_build_number = latest_testflight_build_number(platform: appstore_platform)

    nightly(
      platform: build_platform,
      current_build_number: appstore_build_number,
      export_to_appstore: true
    )

    changelog = default_changelog_for_nightlies(build_platform)

    pilot(
      app_platform: appstore_platform,
      skip_waiting_for_build_processing: skip_waiting_for_build_processing,
      changelog: changelog,
      distribute_external: true,
      groups: ENV['SRGSSR_ITUNES_CONNECT_GROUPS']
    )

    # Wait a bit before asking dSYMs. Not rready yet.
    sleep(60)

    update_dsyms(appstore_platform, ENV['LETTERBOX_DEMO_TVOS_NIGHTLY_APPCENTER_APPNAME'], nil)

    clean_build_artifacts

    save_last_nightlies_success_git_commit_hash(build_platform)
  end

  desc "Common stuff to build a new nightly demo."
  private_lane :nightly do |options|
    platform = options[:platform] ? options[:platform] : "iOS"
    export_to_appstore = options[:export_to_appstore] ? options[:export_to_appstore] : false
    current_build_number = options[:current_build_number]

    increment_build_number(
      build_number: current_build_number + 1
    )

    branch_name = sh "git branch | grep \\* | cut -d ' ' -f2"
    bundle_display_name_suffix = " ðŸŒ™"
    marketing_version_suffix = "-nightly"
    build_name_suffix = ""
    if (branch_name.include? 'feature/')
      bundle_display_name_suffix = " ðŸŒ¿"
      marketing_version_suffix = marketing_version_suffix + '+' + branch_name.sub('feature/', '').strip
      build_name_suffix = '+' + branch_name.sub('feature/', '').strip
    end

    build_lane(
      configuration: "Nightly",
      scheme: "SRGLetterbox-demo",
      bundle_display_name_suffix: bundle_display_name_suffix,
      marketing_version_suffix: marketing_version_suffix,
      build_name_suffix: build_name_suffix,
      platform: platform,
      export_to_appstore: export_to_appstore
    )
  end

  desc "Build a new iOS demo on App Center with the current build number. You are responsible to tag the library version and bump the build number after."
  lane :iOSdemo do
    build_platform = "iOS"

    demo(
      platform: build_platform
    )

    changelog = what_s_new_for_demo()

    appcenter_lane(
      appname: ENV['LETTERBOX_DEMO_IOS_RELEASE_APPCENTER_APPNAME'],
      destinations: ENV['LETTERBOX_DEMO_IOS_RELEASE_APPCENTER_DESTINATIONS'],
      notes: changelog,
      notify_testers: true
    )

    clean_build_artifacts

    print "You are responsible to tag the library version and bump the build number after."
  end

  desc "Build a new tvOS demo on AppStore Connect and wait build processing. Optional 'skip_waiting_for_build_processing' parameter. You are responsible to tag the library version and bump the build number after."
  lane :tvOSdemo do |options|
    skip_waiting_for_build_processing = options[:skip_waiting_for_build_processing] ? options[:skip_waiting_for_build_processing] : false

    update_to_appstore_app_identifier

    build_platform = "tvOS"
    appstore_platform =  "appletvos"

    demo(
      platform: build_platform,
      export_to_appstore: true
    )

    changelog = what_s_new_for_demo()

    pilot(
      app_platform: appstore_platform,
      skip_waiting_for_build_processing: skip_waiting_for_build_processing,
      changelog: changelog,
      distribute_external: true,
      groups: ENV['SRGSSR_ITUNES_CONNECT_GROUPS']
    )

    # Wait a bit before asking dSYMs. Not rready yet.
    sleep(60)

    update_dsyms(appstore_platform, ENV['LETTERBOX_DEMO_TVOS_RELEASE_APPCENTER_APPNAME'], nil)

    clean_build_artifacts

    print "You are responsible to tag the library version and bump the build number after."
  end

  desc "Common stuff to build a new demo."
  private_lane :demo do |options|
    platform = options[:platform] ? options[:platform] : "iOS"
    export_to_appstore = options[:export_to_appstore] ? options[:export_to_appstore] : false

    build_lane(
      configuration: "Release",
      scheme: "SRGLetterbox-demo",
      platform: platform,
      export_to_appstore: export_to_appstore
    )
  end

  desc "Build for a scheme and a configuration"
  private_lane :build_lane do |options|
    scheme = options[:scheme]
    configuration = options[:configuration]
    export_to_appstore = options[:export_to_appstore] ? options[:export_to_appstore] : false
    bundle_display_name_suffix = options[:bundle_display_name_suffix] ? options[:bundle_display_name_suffix] : ""
    marketing_version_suffix = options[:marketing_version_suffix] ? options[:marketing_version_suffix] : ""
    build_name_suffix = options[:build_name_suffix] ? options[:build_name_suffix] : ""
    platform = options[:platform] ? options[:platform] : "iOS"

    # Characters "-" or "+" are not allowed on AppStore Connect.
    if export_to_appstore
      marketing_version_suffix = ""
    end

    team_id = CredentialsManager::AppfileConfig.try_fetch_value(:team_id)

    enable_bitcode_arg = export_to_appstore ? "ENABLE_BITCODE=YES" : "ENABLE_BITCODE=NO"
    xcargs = enable_bitcode_arg + ' BUNDLE_DISPLAY_NAME_SUFFIX="' + bundle_display_name_suffix + '" MARKETING_VERSION_SUFFIX="' + marketing_version_suffix + '" BUILD_NAME_SUFFIX="' + build_name_suffix + '" DEVELOPMENT_TEAM="' + team_id + '" -allowProvisioningUpdates'

    destination = "generic/platform=" + platform

    output_directory = 'fastlane/export/' + lane_context[SharedValues::LANE_NAME] + '/'

    gym(
      configuration: configuration,
      scheme: scheme,
      silent: true,
      clean: true,
      xcargs: xcargs,
      export_method: export_to_appstore ? "app-store" : "enterprise",
      include_bitcode: export_to_appstore,
      export_team_id: team_id,
      destination: destination,
      output_directory: output_directory
    )
  end

  desc "Upload a build on App Center or just a dSYM file."
  private_lane :appcenter_lane do |options|
    appname = options[:appname]
    destinations = options[:destinations]
    notes = options[:notes]
    notify_testers = options[:notify_testers] ? options[:notify_testers] : false
    upload_dsym = options[:upload_dsym]

    if upload_dsym
      appcenter_upload(
        api_token: ENV['LETTERBOX_DEMO_APPCENTER_TOKEN'],
        owner_type: "organization",
        owner_name: ENV['LETTERBOX_DEMO_APPCENTER_OWNER'],
        app_name: appname,
        release_notes: notes,
        upload_dsym_only: true,
        dsym: upload_dsym
      )
    else
      appcenter_upload(
        api_token: ENV['LETTERBOX_DEMO_APPCENTER_TOKEN'],
        owner_type: "organization",
        owner_name: ENV['LETTERBOX_DEMO_APPCENTER_OWNER'],
        app_name: appname,
        release_notes: notes,
        destination_type: "group",
        destinations: destinations,
        notify_testers: notify_testers
      )
    end
  end

  desc "Send latest tvOS nightly dSYMs to App Center, with optional 'version' or 'min_version' parameters."
  lane :nighltyDSYMs do |options|
    update_dsyms("appletvos", ENV['LETTERBOX_DEMO_TVOS_NIGHTLY_APPCENTER_APPNAME'], options)
  end

  desc "Send latest tvOS demo dSYMs to App Center, with optional 'version' or 'min_version' parameters."
  lane :demoDSYMs do |options|
    update_dsyms("appletvos", ENV['LETTERBOX_DEMO_TVOS_RELEASE_APPCENTER_APPNAME'], options)
  end

  # Returns a default changelog for nightlies
  def default_changelog_for_nightlies(platform)

    last_commit_hash = last_nightlies_success_git_commit_hash(platform)
    if last_commit_hash.length < 12
      last_commit_hash = "HEAD^^^^^"
    end

    changelog = changelog_from_git_commits(
        between: [last_commit_hash, "HEAD"],
        pretty: "- %s"
    )
    # HAX: strip emoji from changelog
    changelog = (changelog) ? changelog.sub(/[\u{1F300}-\u{1F6FF}]/, '') : "No change log found for this build."
    Actions.lane_context[SharedValues::FL_CHANGELOG] = changelog
    changelog
  end

  # Return current build number on App Center
  def latest_appcenter_build_number(app_secret)
    appCenterBuildNumber = (sh "scripts/appcenter-build-number.sh -t #{ENV['LETTERBOX_DEMO_APPCENTER_TOKEN']} " + app_secret)
    appCenterBuildNumber = Integer(appCenterBuildNumber.lines.map(&:chomp).last)
    appCenterBuildNumber
  end

  # Save the git commit hash in a local text file for nightlies
  def save_last_nightlies_success_git_commit_hash(platform)
    last = last_git_commit
    platformPrefix = platform ? platform.downcase + "-" : ""
    File.open("last-" + platformPrefix + "nightlies-success-git-commit-hash.txt", 'w') {|f| f.write(last[:commit_hash]) }
    last[:commit_hash]
  end

  # Read the git commit hash in a local text file for nightlies
  def last_nightlies_success_git_commit_hash(platform)
    platformPrefix = platform ? platform.downcase + "-" : ""
    file = File.open("last-" + platformPrefix + "nightlies-success-git-commit-hash.txt", "a+")
    lastNightliesSuccessGitCommitHash = file.read
    file.close
    lastNightliesSuccessGitCommitHash
  end

  # Return the marketing version, without suffix
  def xcode_marketing_version()
     marketing_version = sh 'cd ..; xcodebuild -showBuildSettings | grep "MARKETING_VERSION =" | tr -d " =" | sed "s/MARKETING_VERSION//"'
     marketing_version = marketing_version.lines.last.gsub(/\s+/, "")
     marketing_version
  end

  # Return the bundle app identifier
  def xcode_app_identifier(scheme, configuration)
     app_identifier = sh 'cd ..; xcodebuild -scheme "' + scheme + '" -configuration "' + configuration + '" -showBuildSettings | grep "PRODUCT_BUNDLE_IDENTIFIER =" | tr -d " =" | sed "s/PRODUCT_BUNDLE_IDENTIFIER//"'
     app_identifier = app_identifier.lines.last.gsub(/\s+/, "")
     app_identifier
  end

  # Return current tag version
  def tag_version()
    build_number = get_build_number
    marketing_version = xcode_marketing_version
    tag_version = marketing_version + '-' + build_number
    tag_version
  end

  # Return the what's new text from WhatsNew-demo.json file in the repository
  def what_s_new_for_demo()
    file = File.open("../WhatsNew-demo.json", "r")  
    json = JSON.parse(file.read)
    file.close
    whatsNew = json[tag_version]
    whatsNew ? whatsNew : ''
  end

  # Update only the demo app identifier for App Store Connect submit.
  def update_to_appstore_app_identifier()
    update_app_identifier(
      plist_path: "Demo/Info.plist"
    )
  end

  def update_dsyms (platform, appcenter_app_name, options)
    if options
      min_version = options[:min_version]
      version = options[:version]
    end

    output_directory = 'fastlane/export/' + lane_context[SharedValues::LANE_NAME]
    
    Dir.chdir("..") do
      FileUtils.mkdir_p(output_directory) if !File.directory?(output_directory)
    end

    if min_version
      download_dsyms(
        platform: platform,
        min_version: min_version,
        output_directory: output_directory
      )
    elsif version
      download_dsyms(
        platform: platform,
        version: version,
        output_directory: output_directory
        )
    else
      download_dsyms(
        platform: platform,
        version: "latest",
        output_directory: output_directory
        )
    end

    if lane_context[SharedValues::DSYM_PATHS]
      lane_context[SharedValues::DSYM_PATHS].each { |dSYM|
        appcenter_lane(
          appname: appcenter_app_name,
          notes: 'DSYMs from AppStore Connect (via fastlane).',
          upload_dsym: dSYM
        )
      }
    end
  end

  after_all do |lane|
    if (!lane.to_s.downcase.include? 'dsym')
      reset_git_repo(skip_clean: true)
    end

    # slack(
    #   message: "Successfully deployed new App Update."
    # )
  end

  error do |lane, exception|
    if (!lane.to_s.downcase.include? 'dsym')
      clean_build_artifacts
      reset_git_repo(skip_clean: true, force: true)
    end

    # slack(
    #   message: exception.message,
    #   success: false
    # )
  end
end

def clean_result_files
  Dir['*.xml'].each { |file| File.delete(file) }
  Dir['*.xcresult'].each { |folder| FileUtils.remove_entry(folder, true) }
end

# Override test product names to split iOS and tvOS test results
def override_test_product_names
  set_xcconfig_value(
    path: 'Tests/Tests.xcconfig',
    name: 'PRODUCT_NAME[sdk=iphone*]',
    value: '$(PROJECT_NAME)-iOS'
  )
  set_xcconfig_value(
    path: 'Tests/Tests.xcconfig',
    name: 'PRODUCT_NAME[sdk=appletv*]',
    value: '$(PROJECT_NAME)-tvOS'
  )
end

def run_tests_with_devices(devices)
  devices.each do |device|
    srg_scan(device)
    copy_last_xcresult
  end
  check_xcresult_count(devices)
end

def srg_scan(device)
  scan(
    device: device,
    scheme: xcode_library_scheme,
    output_types: '',
    output_style: FastlaneCore::Env.truthy?('TRAVIS') ? 'raw' : 'standard',
    fail_build: false,
    clean: true
  )
end

def xcresults_path
  derived_data_path = lane_context[SharedValues::SCAN_DERIVED_DATA_PATH]
  derived_data_path + '/Logs/Test/'
end

def copy_last_xcresult
  file = nil
  Dir.chdir(xcresults_path) do
    # max == sort.last
    file = Dir['*.xcresult'].max
  end
  file_name = File.basename(file)
  FileUtils.copy_entry(xcresults_path + file_name, file_name)
end

def check_xcresult_count(devices)
  return unless Dir['*.xcresult'].count != devices.count

  UI.user_error!('Whoops, unexpected xcresult file count.')
end

# Returns the library scheme
def xcode_library_scheme
  scheme = nil
  Dir.chdir('..') do
    scheme = sh 'xcodebuild -list | grep "Schemes:" -A 1'
  end
  scheme ['Schemes:'] = ''
  scheme.gsub(/\s+/, '').chomp
end

# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md
# All available actions: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Actions.md

# fastlane reports which actions are used
# No personal data is recorded. Learn more at https://github.com/fastlane/enhancer